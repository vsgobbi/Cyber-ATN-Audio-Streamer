__author__ = 'vitor'

#!/usr/bin/env python

""""
 This is the client code for python-gstreamer.
 The gstreamer TCP/IP client sends a file
 through a tcpclientsink to a server on localhost
 The default location to our Cyber Range ATN Testbed sounds is "/opt/crat/core/home/sounds/"
 To check output generated by the logging files type on terminal: tail -f /path/to/file/AudioStreamerLogging.log
 Created at ICEA (Brazilian Airspace Control Institute)
 Vitor Sgobbi, 2015
"""""


""""
# NOTES:
# After a long time testing the codecs missing and searching for it...
# If you consider playing .mp3 files, check if 'mad' element plugin is installed with gst0.10, install it with:
# apt-get install gstreamer0.10-fluendo-mp3

# Example of how to test with gst-launch-0.10 terminal command:
# gst-launch-0.10 tcpserversrc host=localhost port=3000 ! decodebin ! audioconvert ! alsasink
# gst-launch-0.10 filesrc location=/home/user/Music/Gorillaz_Feel_Good_Inc.mp3 ! tcpclientsink host=localhost port=3000
"""""


import gobject, pygst
pygst.require("0.10")

import os, sys, random, fnmatch, glob, time, signal, logging, logging.config, logging.handlers
from os.path import expanduser
#import threading, getopt, Queue #unused

# Setting GST_DEBUG_DUMP_DOT_DIR environment variable enables us to have a dotfile generated
os.environ["GST_DEBUG_DUMP_DOT_DIR"] = "/tmp"
os.putenv("GST_DEBUG_DUMP_DIR_DIR", "/tmp")
try:
    import gi
except:
    pass
try:
    import pygst
    pygst.require("0.10")
    import gst
except:
    pass


#create a logging file and its configs
logging.basicConfig(filename='AudioStreamerLogging.log', level=logging.DEBUG,format='%(asctime)s: %(message)s', datefmt='%d/%m/%Y %I:%M:%S %p')

#create the logger
logger = logging.getLogger('ATC Client log') #__name__
logging.info('\n\nATC client has just connected...\n')

#add log handler so it can have max of 32mb file
handler = logging.handlers.RotatingFileHandler('AudioStreamerLogging.log', maxBytes=2^15, backupCount=0)
logger.addHandler(handler)

# create the pipeline and add client [ filesrc ! tcpclientsink ]
pipeline = gst.Pipeline("client")

#player = gst.element_factory_make("playbin", "player")
src = gst.element_factory_make("filesrc", "source")
logger.debug('Debug msg: %s' % src + ' created')

#Sort .mp3 files randomly in our ATC sounds directory and check necessary conditions

files = []
rand = []
shuffle_files = []
path = os.path.join("/opt/crat/core/home/sounds/ATC/")
#def getFiles():
#    chosen = random.choice(os.listdir(src_path))
#    return os.path.join(src_path, chosen)

def getFiles(path):
    if os.path.isdir(path) == False:
        print "\nThe required folder %s" % path + " doesn't exist\n" + "Please extract all ATC songs or contact the admin\n"
        logging.error('The user has no path: %s', path)
        exit(-1)
    #make it even more randomly :D
    random.seed()
    for f in sorted(os.listdir(path), key=lambda k: random.random()):
        f = os.path.join(path, f)
        if os.path.isdir(f): getFiles(f)
        if len(files) > 398: break
        if fnmatch.fnmatch(f, '*.mp3'):
            files.append(f)
        f.rstrip().split('\n')
        #logging.info("'f' value: %s", f)
        #print '\n' + f
        random.shuffle(files) #return none, just rand again

        if len(files) < 1:
            print "Hey, we must have at least one playable sound file!"
            logging.error('The path: %s', path + 'seems to be empty!')
            return

getFiles(os.path.expanduser(path))
logging.info('Total of %s' % len(files) + ' files found for ATC.')

def signal_handler(signal, frame):
    print '\nYou pressed Ctrl + C, quitting!'
    logging.warn('The user exited the ATC client streamer.')
    sys.exit(0)

print 'Press Ctrl+C to exit'
if KeyboardInterrupt:
    #time.sleep(1)
    signal.signal(signal.SIGINT, signal_handler)

''''
for n in files:
    #rand = random.shuffle(files)
    i = 0
    random.shuffle(files)
    files.pop(i)
    rand = random.choice(files)
    i += 1
    logger.info('Post increment value: %s' % i)
'''''

'''''
#Better way to call and make a list?
shuffle_files = []
file_listing = []
types = ('*.mp3','*.ogg','*.wav')
def getFiles2():
    files = open("/opt/crat/core/home/sounds/ATC/ATC.m3u", "r")
    listpath = glob.glob("/opt/crat/core/home/sounds/ATC/" + "*.mp3")
    random.shuffle(list)
    for line in file.readlines():
        files.append(os.path.abspath(line))
    random.seed()
    list = open(path).read().rstrip().split('\n')
    for file_listing in listpath:
        files.extend(glob.glob("/opt/crat/core/home/sounds/ATC"))
        if fnmatch.fnmatch(file_listing, '*.mp3'):
            file_listing.rstrip().split('\n')
            files.append(file_listing)
            shuffle_files = random.choice(files)
            print "\n" + shuffle_files
        print file_listing

    return  files

    #for t in range(len(files), 1, -1):
        #track = random.randint(1, t -1)
        #shuffle_files.append(track)
       #remove and return item as last of list
        #files.pop(track)
        #print "Playing track '%s'" % track

    #for line in files:
    #    files.append(os.path.abspath(line))
    #    files.pop(file_listing)
    #    print file_listing
    #    print list
    #shuffle_files = []
    #
    #for t in range(len(files), 1, -1):
    #    track = random.randint(1, t -1)
    #    shuffle_files.append(files[track])
       #remove and return item as last of list
    #    files.pop(track)
    #    print "Playing track '%s'" % track
       #print "Playing track '%s'" % track

#getFiles2()
    #rand = random.shuffle(files)
    #make shuffling files to be added as string
    #rand = random.shuffle(getFiles(path))

    #rand = random.shuffle(files)
    #inputDir = os.getcwd()

    #select the current path and return it as a string
    #path = os.getcwd()

def songs():
    #global i, files
    while i:
        yield (files[i])
        i += 1
        if i >=len(files): i=0 #adiciona os arquivos na pilha,
        #quando quantia de sons tocados forem igual o numero de arquivos
        #volta para inicio
        #pipeline.set_state(gst.STATE_PLAYING)
        #print 'Playing file...'

def peekSongs(n):
    nexti = i + 1
    if nexti >= len(files): nexti = 0
    return map((files[nexti]+files[:nexti])[:n])

player = gst.parse_launch("playbin uri=file://%s" % getFiles())
player_bus = player.get_bus()
player_bus.add_signal_watch()
player_bus.connect("message::eos", alert_ended)
player.set_state(gst.STATE_PLAYING)

src.set_property("location", files.pop(i))
src.set_property("location", rand) #everything going wrong here... change failure

'''''

#add all elements to pipeline
pipeline.add(src)

#set client properties for TCP usage and create pipeline #uncomment it if you wish to receive streaming data via TCP
#client = gst.element_factory_make("tcpclientsink", "client")

#set client properties for UDP usage and create pipeline
client = gst.element_factory_make("udpsink", "client")

pipeline.add(client)
client.set_property("host", "0.0.0.0")
client.set_property("port", 3030)
src.link(client)
logging.debug(src)
logging.debug('%s' % client)
logging.info("Client UDP sink configured at host: 0.0.0.0 and UDP port usage at: 3030")



#check if pipeline and sources are okay
if (not pipeline or not src or not files):
    print 'Client problem found... Not all elements could be created.'
    logging.error("Client problem found at ATC script, some of elements were not create.")
    exit(-1)


def statePlay():
    i = 1
    for n in files:
        #gst.StateChangeReturn
        #pipeline.set_state(gst.STATE_PLAYING)
        #pipeline.continue_state(gst.BUFFERING_STREAM)

        while True:
            print "\nI'm in..." #just for testing because I'm a newbie guy
            #i=range(0,len(files))
            #poppedfiles = files.pop(-1) # -1 get the item at end #if want to remove a specific value use : indexList.remove()
            poppedfiles = random.choice(files)
            #pipeline.set_state(gst.BUFFER_LIST_CONTINUE)
            #statePlay()
            src.set_property("location", poppedfiles)
            print 'Playing file: %s' % poppedfiles
            logging.debug('ATC iteration: %s' % i + ', currently playing file: %s' % poppedfiles)
            pipeline.set_state(gst.STATE_PLAYING)
            #pipeline.set_state(gst.STATE_CHANGE_SUCCESS) #not handling buffer, making audio sink every time
            random.seed() #seed again
            gammapdf = random.gammavariate(3, 2)  #atc gamma distribution statistics where alpha = 3 and beta = 2
            print "The random gamma probability distribution function has generated: %s" % round(gammapdf, 1) + " seconds of interarrival time \n"

            time.sleep(gammapdf) # get the length of file and add to time sleep!

            if i >=len(files):
                i = 0 #come back to index zero
                print >> sys.stderr, "Reached the end of files, returning..."
                logging.debug('Reached the end of ATC files! %s' % len(files))
            if n <=i:
                #n = 0
                print >> sys.stderr, "Reached the bottom!", n
                pipeline.set_state(gst.StateChangeReturn(1))

            #pipeline.set_state(gst.StateChangeReturn(1))
            pipeline.set_state(gst.STATE_CHANGE_SUCCESS) #this is making it to play the same audio file!
            i+=1

        #n+=1
        #i+=1
    logger.debug(gst.STATE_PLAYING)
    logger.info("Did I reach the end?")



def printMsgs():
    bus = pipeline.get_bus()
    bus.add_signal_watch()
    #msg = bus.timed_pop_filtered(gst.CLOCK_TIME_NONE, gst.MESSAGE_ERROR | gst.MESSAGE_EOS)
    msg = bus.timed_pop_filtered(gst.MESSAGE_ERROR, gst.MESSAGE_EOS)
    pipeline.set_new_stream_time(1) #default was 15
    print 'Stopped here!'
    restart = pipeline.set_state(gst.STATE_PLAYING)
    #print 'Playing files...'
    if restart == gst.STATE_CHANGE_FAILURE:
        print >> sys.stderr, ("Unable to set pipeline to playing state, pulling over!")
        exit (-1)
    elif restart == gst.STATE_CHANGE_NO_PREROLL:
        print >> sys.stderr, ("There is no preroll")
        pipeline.continue_state(src)
    #pipeline.set_state(gst.STATE_NULL)
    logging.info("Get status: %s", restart)
    logger.debug(restart)
    print msg


#if not set to NULL the pipeline doesn't free resources
#pipeline.set_state(gst.STATE_NULL)
#pipeline.set_state(gst.STATE_CHANGE_NULL_TO_READY)
#pipeline.set_state(gst.STATE_PLAYING)


#enter into a mainloop
#gobject.start_new_thread()
loop = gobject.MainLoop()
gobject.threads_init()
context = loop.get_context()
statePlay()
printMsgs()
#loop.run()
#pipeline.set_state(gst.STATE_PLAYING)


while True:

    #pipeline.set_state(gst.STATE_PLAYING)
    print "state playing in the while loop"
    context.iteration(True)


#16/07/2015 - The client after playing the file is closing connection, while the server script is still working and sinking